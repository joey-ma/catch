document.addEventListener('DOMContentLoaded', () => {

  const welcomeMessage = 'Welcome!\n'
    + "This game contains sound effects triggered by game events.\nHint: If you're at work, you might want to mute your audio. \n\n"
    + 'Some optional keyboard shortcuts:\n'
    + 'Press P to play and pause the music, and M to mute.\n'
    + 'Press E, N, H to set game level to Easy, Normal, or Hard.\n'
    + 'Press Enter to restart the game.\n';
  
  function alertNotOptimized() {
    // console.log('ideal screenX position:', ((window.screen.availWidth - window.outerWidth) / 2));
    // console.log('ideal screenY position:', ((window.screen.availHeight - window.innerHeight) / 2));
    console.log(`availWidth: ${window.screen.availWidth}, availHeight: ${window.screen.availHeight}`);
    console.log(`innerWidth: ${window.innerWidth}, innerHeight:${window.innerHeight}`);
    console.log(`outerWidth: ${window.outerWidth}, outerHeight: ${window.outerHeight}`);
    console.log(`innerWidth: ${window.innerWidth < 720}, innerHeight: ${window.innerHeight < 870}`);
    // console.log('screenX: ' + window.screenX + ', screenX: ' + window.screenY);
    // console.log(window);
    if (window.innerWidth < 720 || window.innerHeight < 870) {
      window.alert('Please enjoy this game on a device / browser window larger than 720 x 900 pixels. \n\nAlso note: sound effects are not supported on iOS devices. \n\nThis game is optimized for Google Chrome on a desktop. Thanks!');
    }
    // iPad Mini
    if (window.innerWidth === 768 && window.innerHeight === 1024) {
      window.alert('Sorry, sound effects are not supported on iOS devices. Thanks!');
    }
    // iPad
    if (window.innerWidth === 820 && window.innerHeight === 1180) {
      window.alert('Sorry, sound effects are not supported on iOS devices. Thanks!');
    }
    // iPad Pro
    if (window.innerWidth === 1024 && window.innerHeight === 1366) {
      window.alert('Sorry, sound effects are not supported on iOS devices. Thanks!');
    }
  }

  function alertOnce(message) {
    const cookieFound = document.cookie.split('; ').find((row) => row.startsWith('alerted'));
    // const cookieValue = document.cookie.split('; ').find((row) => row.startsWith('test2='))?.split('=')[1];
    console.log(`ðŸš€ -> file: main.js:21 -> alertOnce -> cookieFound`, cookieFound);
    
    if (cookieFound) {
      console.log(`cookie found, do not alert: ${document.cookie}`)
    } else {
      console.log(`cookie not found, alerting: ${document.cookie}`)
      // It is more common not to set the `SameSite` attribute, which results in the default, and more secure, value of `SameSite=Lax;`
      // Note that I am setting `SameSite=None;` I'd like it to work cross-origin.
      document.cookie = "alerted=true; expires=Fri, 31 Dec 9999 23:59:59 GMT; SameSite=None; Secure;"
      // ! cookie not being written on my desktop macOS Monterey Version 12.6.1 (21G217) + Safari Version 16.2 (17614.3.7.1.7, 17614)

      alert(message);
    }
  }

  alertOnce(welcomeMessage);

  alertNotOptimized(); // alert not optimized every time better than alerting one time; game is more enjoyable on desktop

  console.log(welcomeMessage); // console logs every time for those who wants to check out the browser console

  // * for wip pausing game functionality
  // const gamePaused = {
  //   speed: 250,
  //   status: false,
  // };

  // bgm setup
  // let musicPlayer;

  const musicPlayer = document.querySelector('#controllersContainer > audio');
  musicPlayer.volume = 0.15;

  const bgmFiles = [
    './assets/bgm/109-pewter_city_theme.mp3',
    './assets/bgm/133-celadon_city.mp3',
    './assets/bgm/107-battle_vs_wild_pokemon.mp3',
  ];

  let i = 0;

  // listen for the music ended event, to play the next audio file
  musicPlayer.addEventListener('ended', () => {
    if (i < bgmFiles.length) {
      musicPlayer.src = bgmFiles[i];
      i += 1;
      // if intro music ends, play next song
      musicPlayer.play();
      // musicPlayer.loop = true;
    } else {
      i = 0;
      musicPlayer.src = bgmFiles[i];
      i += 1;
      // if intro music ends, play next song
      musicPlayer.play();
    }
  }, false);

  const body = document.querySelector('body');
  const gameboard = document.querySelector('#gameboard');

  const head = new Head(gameboard);
  const apple = new Apple(gameboard);

  // * added key press functionality for desktop / laptop users
  // 'keydown' is the case-sensitive string of event type to listen for
  body.addEventListener('keydown', (e) => {
    // the KeyboardEvent is the js built-in object with several properties
    // KeyboardEvent.code represents a physical key on the keyboard
    // (as opposed to the character generated by pressing the key)
    // KeyboardEvent.key returns the value of the key pressed by the user

    switch (e.code) {
      case 'ArrowLeft':
        if (head.currentDirection !== 'right') head.input = 'left';
        break;
      case 'ArrowRight':
        if (head.currentDirection !== 'left') head.input = 'right';
        break;
      case 'ArrowUp':
        if (head.currentDirection !== 'down') head.input = 'up';
        break;
      case 'ArrowDown':
        if (head.currentDirection !== 'up') head.input = 'down';
        break;
      // using keyboard for speed management: e = easy, n = normal, h = hard
      case 'KeyE':
        head.SPEED = 500;
        console.log('Game level set to Easy.');
        break;
      case 'KeyN':
        head.SPEED = 250;
        console.log('Game level set to Normal.');
        break;
      case 'KeyH':
        head.SPEED = 75;
        console.log('Game level set to Hard.');
        break;
      // using keyboard to mute music
      case 'KeyM':
        if (musicPlayer.volume === 0) {
          musicPlayer.volume = 0.15;
          console.log('Music volume turned to 0.15 here.');
        } else {
          musicPlayer.volume = 0;
          console.log('Music volume turned to 0 here.');
        }

        if (head.death.muted === false) head.death.muted = true;
        else head.death.muted = false;
        
        break;
      // using keyboard to play / pause music
      case 'KeyP':
        // console.log('music player paused:', musicPlayer.paused, 'game over music paused: ', head.death.paused)

        if (head.gameOverStatus) {
          if (!head.death.paused) {
            head.death.pause();
          } else {
            head.death.play();
          }
          return;
        }

        if (musicPlayer.paused) {
          musicPlayer.play();
        } else {
          musicPlayer.pause();
        }

        break;
      // reloads page when hitting 'Enter' key
      case 'Enter':
        window.location.reload();
        break;
      // todo stretch feature: pause functionality ...
      // case 'Space':
      //   console.log(
      //     'gamePaused: ',
      //     gamePaused.status,
      //     'head.SPEED (current)',
      //     head.SPEED,
      //     'prior speed:',
      //     gamePaused.speed,
      //     'current direction:',
      //     head.currentDirection,
      //   );
      //   if (!gamePaused.status) {
      //     gamePaused.speed = Number(head.SPEED);
      //     gamePaused.status = true;
      //     head.SPEED = 1000000;
      //     console.log(
      //       'gamePaused: ',
      //       gamePaused.status,
      //       'head.SPEED (current)',
      //       head.SPEED,
      //       'prior speed:',
      //       gamePaused.speed,
      //       'current direction:',
      //       head.currentDirection,
      //     );
      //   } else {
      //     gamePaused.status = false;
      //     head.SPEED = Number(gamePaused.speed);
      //     gamePaused.speed = 1000000;
      //     console.log(
      //       'paused: ',
      //       gamePaused.status,
      //       'head.SPEED (current)',
      //       head.SPEED,
      //       'prior speed:',
      //       gamePaused.speed,
      //       'current direction:',
      //       head.currentDirection,
      //     );
      //   }
      //   break;
      default:
        // console.log(`${e.code} is not recognized`);
        break;
    }
  });

  const easyButton = document.createElement('button');
  easyButton.setAttribute('class', 'challengeLevel');
  easyButton.innerText = 'Easy';
  easyButton.addEventListener('click', () => {
    console.log('Game level set to Easy.');
    head.SPEED = 500;
  });

  const normalButton = document.createElement('button');
  normalButton.setAttribute('class', 'challengeLevel');
  normalButton.innerText = 'Normal';
  normalButton.addEventListener('click', () => {
    console.log('Game level set to Normal.');
    head.SPEED = 250;
  });

  const hardButton = document.createElement('button');
  normalButton.setAttribute('class', 'challengeLevel');
  hardButton.innerText = 'Hard';
  hardButton.addEventListener('click', () => {
    console.log('Game level set to Hard.');
    head.SPEED = 75;
  });

  // const sfxButton = document.createElement('button');
  // sfxButton.setAttribute('class', 'challengeLevel');
  // sfxButton.innerText = 'SFX On';
  // sfxButton.addEventListener('click', () => {
  //   console.log('Game sfx loaded.');
  //   head.bonk.load();
  //   head.death.load();
  //   head.eat.load();
  // });

  const span = document.createElement('span');
  span.id = 'levelButtons';
  span.appendChild(easyButton);
  span.appendChild(normalButton);
  span.appendChild(hardButton);

  document.querySelector('#controllersContainer').appendChild(span);
  // document.querySelector('#controllersContainer').appendChild(sfxButton);

  // if player wishes to play again, reload the page
  document.querySelector('#again').addEventListener('click', () => {
    window.location.reload();
  });

  const touch = {
    start: { x: null, y: null },
    end: { x: null, y: null },
  };

  gameboard.addEventListener('touchstart', (e) => {
    e.preventDefault();
    touch.start.x = e.changedTouches[0].clientX;
    touch.start.y = e.changedTouches[0].clientY;
    // console.log(`x, y starting points: ${touch.start.x}, ${touch.start.y}`);
  });

  gameboard.addEventListener('touchmove', (e) => {
    // works similar to 'touchend', but allows control of continuous touch movement
    // gameboard.addEventListener('touchend', (e) => {
    touch.end.x = e.changedTouches[0].clientX;
    touch.end.y = e.changedTouches[0].clientY;
    // console.log(`x, y ending points: ${touch.end.x}, ${touch.end.y}`);
    const xDifference = touch.end.x - touch.start.x;
    // < -20 means swipe left || > 20 means swipe right
    const yDifference = touch.end.y - touch.start.y;
    // < -20 means swipe up || > 20 means swipe down
    const swipeLeft = xDifference < -20;
    const swipeRight = xDifference > 20;
    const swipeUp = yDifference < -20;
    const swipeDown = yDifference > 20;
    // console.log(`x, y differences: ${xDifference}, ${yDifference}`);

    if (swipeLeft && Math.abs(xDifference) > Math.abs(yDifference) && head.currentDirection !== 'right') {
      head.input = 'left';
    }
    if (swipeRight && Math.abs(xDifference) > Math.abs(yDifference) && head.currentDirection !== 'left') {
      head.input = 'right';
    }
    if (swipeUp && Math.abs(xDifference) < Math.abs(yDifference) && head.currentDirection !== 'down') {
      head.input = 'up';
    }
    if (swipeDown && Math.abs(xDifference) < Math.abs(yDifference) && head.currentDirection !== 'up') {
      head.input = 'down';
    }
  });

  // end of DOMContentLoaded event listener
});

// todo stretch features?
// - add iPad support for touch input swiping up, down, left, right // * done!
// - add iPad support for continuous touch input swiping up, down, left, right // * done!
// ? might be good to add instruction for touch input somewhere?
// ? confirmed behavior for Safari: cannot play audio without user initiated action.
  // ? If you do not set the controls attribute, you must either set the autoplay attribute, ?
  // ? create a controller using JavaScript, or play the movie programmatically from JavaScript. ?
  // ? Otherwise the user has no way to play the movie. ?
  // ? Warning: To prevent unsolicited downloads over cellular networks at the userâ€™s expense, ?
  // ? embedded media cannot be played automatically in Safari on iOSâ€”-user always initiates playback. ?
  // ? A controller is automatically supplied on iPhone or iPod touch once playback in initiated, ?
  // ? but for iPad you must either set the controls attribute or provide a controller using JavaScript. ?
// - instead of reducing chance of apple spawning where snake is, maybe rework logic? // * done!
// - turn off the music autoplay // * done!
// - add mute/unmute function with keyM to mute the music // * done!
// - add play/pause function with keyP to play/pause the music // * done!
// - throttling seems not needed in current set up, but would be needed if this.input is removed
// - currently music plays a small number of songs, more songs and a more advanced algo would be a plus
// - add a pause functionality when hitting space bar
// - look into error message(s):
  // Uncaught ReferenceError: time is not defined // ? seems like it is needed though
  // at Head.gameOver(Head.js: 144: 18)
  // at Head.move(Head.js: 75: 34)
